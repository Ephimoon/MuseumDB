Index: frontend/src/App.jsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// src/App.jsx\r\n\r\nimport React from 'react';\r\nimport { ToastContainer } from 'react-toastify';\r\nimport 'react-toastify/dist/ReactToastify.css';\r\nimport { BrowserRouter, Route, Routes, Navigate } from 'react-router-dom';\r\nimport PrivateRoute from './components/PrivateRoute';\r\nimport Home from './pages/Home';\r\nimport Visit from './pages/Visit';\r\nimport ExhibitionsAndEvents from './pages/ExhibitionsAndEvents';\r\nimport Art from './pages/Art';\r\nimport MFAShop from './pages/MFAShop';\r\nimport BecomeAMember from './pages/BecomeAMember';\r\nimport BuyTickets from './pages/BuyTickets';\r\nimport AdminDashBoard from './pages/Dashboards/AdminDashboard';\r\nimport LoginPage from './pages/LoginPage';\r\nimport RegisterPage from './pages/RegisterPage';\r\nimport VerifyPage from './pages/VerifyPage';\r\nimport LogoutPage from './pages/LogoutPage';\r\nimport StaffDashboard from './pages/Dashboards/StaffDashboard';\r\nimport GiftShopAdmin from './components/GiftShopAdmin';\r\nimport ManageUsers from './components/ManageUsers'; // Imported ManageUsers\r\nimport EventDirectorDashboard from './pages/Dashboards/EventDashboard';\r\nimport EventReport from './pages/Dashboards/EventReport';\r\nimport CurateArt from './pages/Dashboards/CurateArt';\r\nimport CurateExhibitions from './pages/Dashboards/CurateExhibitions';\r\nimport ProfilePage from './pages/ProfilePage';\r\nimport MFAShopStaff from './pages/Dashboards/MFAShopStaff';\r\nimport ShopReport from './pages/Dashboards/ShopReport';\r\nimport Cart from './pages/Cart';\r\nimport Checkout from './pages/Checkout';\r\nimport TicketCart from './pages/TicketCart';\r\nimport TicketCheckout from './pages/TicketCheckout';\r\nimport MemberDashboard from './pages/Dashboards/MemberDashboard/MemberDashboard';\r\nimport Settings from './pages/Dashboards/MemberDashboard/Settings';\r\nimport Report from './pages/Report';\r\n<<<<<<< Updated upstream\r\n\r\n=======\r\nimport { TicketCartProvider } from './components/TicketCartContext';\r\nimport AdminDashboard from \"./pages/Dashboards/AdminDashboard\";\r\nimport MyTicket from \"./components/MyTickets\"\r\n// Manage Users\r\nimport ManageUsers from '../src/components/ManageUsers';\r\n>>>>>>> Stashed changes\r\nconst App = () => {\r\n    const username = localStorage.getItem('username'); // Check if a user is logged in\r\n    const role = localStorage.getItem('role'); // Get user role\r\n\r\n    return (\r\n        <BrowserRouter>\r\n<<<<<<< Updated upstream\r\n            <ToastContainer />\r\n            <Routes>\r\n                {/* Public Routes - Accessible to all users */}\r\n                <Route path=\"/\" element={<Home />} />\r\n                <Route path=\"/Visit\" element={<Visit />} />\r\n                <Route path=\"/ExhibitionsAndEvents\" element={<ExhibitionsAndEvents />} />\r\n                <Route path=\"/Art\" element={<Art />} />\r\n                <Route path=\"/MFAShop\" element={<MFAShop />} />\r\n                <Route path=\"/shop\" element={<MFAShop />} />\r\n                <Route path=\"/cart\" element={<Cart />} />\r\n                <Route path=\"/checkout\" element={<Checkout />} />\r\n                <Route path=\"/BecomeAMember\" element={<BecomeAMember />} />\r\n                <Route path=\"/BuyTickets\" element={<BuyTickets />} />\r\n=======\r\n            <ToastContainer\r\n                position=\"top-right\"\r\n                autoClose={5000}\r\n                hideProgressBar={false}\r\n                newestOnTop={false}\r\n                closeOnClick\r\n                rtl={false}\r\n                pauseOnFocusLoss\r\n                draggable\r\n                pauseOnHover\r\n                theme=\"colored\"\r\n            />\r\n            <TicketCartProvider>\r\n                <Routes>\r\n                    <Route path=\"/\" element={<Home />} />\r\n                    <Route path=\"/Visit\" element={<Visit />} />\r\n                    <Route path=\"/ExhibitionsAndEvents\" element={<ExhibitionsAndEvents />} />\r\n                    <Route path=\"/Art\" element={<Art />} />\r\n                    <Route path=\"/MFAShop\" element={<MFAShop />} />\r\n                    <Route path=\"/shop\" element={<MFAShop />} />\r\n                    <Route path=\"/cart\" element={<Cart />} />\r\n                    <Route path=\"/checkout\" element={<Checkout />} />\r\n                    <Route path=\"/BecomeAMember\" element={<BecomeAMember />} />\r\n                    <Route path=\"/BuyTickets\" element={<BuyTickets />} />\r\n                    <Route path=\"/ticket-checkout\" element={<TicketCheckout />} />\r\n>>>>>>> Stashed changes\r\n\r\n                {/* Authentication Routes */}\r\n                <Route path=\"/login\" element={<LoginPage />} />\r\n                <Route path=\"/register\" element={<RegisterPage />} />\r\n                <Route path=\"/verify\" element={<VerifyPage />} />\r\n                <Route path=\"/logout\" element={<LogoutPage />} />\r\n\r\n                {/* Member Routes - Accessible to logged-in members */}\r\n                <Route element={<PrivateRoute roles={['member', 'customer']} />}>\r\n                    <Route path=\"/MemberDashboard\" element={<MemberDashboard />} />\r\n                    <Route path=\"/Settings\" element={<Settings />} />\r\n                </Route>\r\n\r\n                {/* Admin Routes - Accessible to admin users only */}\r\n                <Route element={<PrivateRoute roles={['admin']} />}>\r\n                    <Route path=\"/AdminDashBoard\" element={<AdminDashBoard />} />\r\n                    <Route path=\"/giftshop-admin\" element={<GiftShopAdmin />} />\r\n                    <Route path=\"/manage-users\" element={<ManageUsers />} /> {/* New Route */}\r\n                </Route>\r\n\r\n                {/* Staff and Admin Dashboard Routes */}\r\n                <Route element={<PrivateRoute roles={['admin', 'staff']} />}>\r\n                    <Route path=\"/StaffDashboard\" element={<StaffDashboard />} />\r\n                    <Route path=\"/EventDirectorDash\" element={<EventDirectorDashboard />} />\r\n                    <Route path=\"/event-report\" element={<EventReport />} />\r\n                    <Route path=\"/curate-art\" element={<CurateArt />} />\r\n                    <Route path=\"/curate-exhibitions\" element={<CurateExhibitions />} />\r\n                    <Route path=\"/MFAShopStaff\" element={<MFAShopStaff />} />\r\n                    <Route path=\"/shop-report\" element={<ShopReport />} />\r\n                    <Route path=\"/reports\" element={<Report />} />\r\n                </Route>\r\n\r\n                {/* Profile Page - Accessible to all logged-in users */}\r\n                <Route element={<PrivateRoute roles={['admin', 'staff', 'customer', 'member']} />}>\r\n                    <Route path=\"/profile\" element={<ProfilePage />} />\r\n                </Route>\r\n\r\n<<<<<<< Updated upstream\r\n                {/* Redirect unknown routes to home */}\r\n                <Route path=\"*\" element={<Navigate to=\"/\" replace />} />\r\n            </Routes>\r\n=======\r\n                    {/* Profile Page */}\r\n                    <Route element={<PrivateRoute roles={['admin', 'staff', 'customer', 'member']} />}>\r\n                        <Route path=\"/profile\" element={<ProfilePage />} />\r\n                        <Route path=\"/ticket-cart\" element={<TicketCart />} />\r\n                        <Route path=\"/ticket-checkout\" element={<TicketCheckout />} />\r\n                        <Route path=\"/mytickets\" element={<MyTicket />} />\r\n                    </Route>\r\n                </Routes>\r\n            </TicketCartProvider>\r\n>>>>>>> Stashed changes\r\n        </BrowserRouter>\r\n    );\r\n};\r\n\r\nexport default App;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/frontend/src/App.jsx b/frontend/src/App.jsx
--- a/frontend/src/App.jsx	(revision 13a78189c8e40ebcb2fc4e34d15700aca0e7aa8d)
+++ b/frontend/src/App.jsx	(date 1731863928000)
@@ -34,9 +34,6 @@
 import MemberDashboard from './pages/Dashboards/MemberDashboard/MemberDashboard';
 import Settings from './pages/Dashboards/MemberDashboard/Settings';
 import Report from './pages/Report';
-<<<<<<< Updated upstream
-
-=======
 import { TicketCartProvider } from './components/TicketCartContext';
 import AdminDashboard from "./pages/Dashboards/AdminDashboard";
 import MyTicket from "./components/MyTickets"
@@ -49,7 +46,6 @@
 
     return (
         <BrowserRouter>
-<<<<<<< Updated upstream
             <ToastContainer />
             <Routes>
                 {/* Public Routes - Accessible to all users */}
@@ -63,7 +59,6 @@
                 <Route path="/checkout" element={<Checkout />} />
                 <Route path="/BecomeAMember" element={<BecomeAMember />} />
                 <Route path="/BuyTickets" element={<BuyTickets />} />
-=======
             <ToastContainer
                 position="top-right"
                 autoClose={5000}
@@ -89,8 +84,6 @@
                     <Route path="/BecomeAMember" element={<BecomeAMember />} />
                     <Route path="/BuyTickets" element={<BuyTickets />} />
                     <Route path="/ticket-checkout" element={<TicketCheckout />} />
->>>>>>> Stashed changes
-
                 {/* Authentication Routes */}
                 <Route path="/login" element={<LoginPage />} />
                 <Route path="/register" element={<RegisterPage />} />
@@ -126,12 +119,9 @@
                 <Route element={<PrivateRoute roles={['admin', 'staff', 'customer', 'member']} />}>
                     <Route path="/profile" element={<ProfilePage />} />
                 </Route>
-
-<<<<<<< Updated upstream
                 {/* Redirect unknown routes to home */}
                 <Route path="*" element={<Navigate to="/" replace />} />
             </Routes>
-=======
                     {/* Profile Page */}
                     <Route element={<PrivateRoute roles={['admin', 'staff', 'customer', 'member']} />}>
                         <Route path="/profile" element={<ProfilePage />} />
@@ -141,7 +131,6 @@
                     </Route>
                 </Routes>
             </TicketCartProvider>
->>>>>>> Stashed changes
         </BrowserRouter>
     );
 };
Index: frontend/src/server.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const express = require('express');\r\nconst mysql = require('mysql2/promise');\r\nconst cors = require('cors');\r\nconst multer = require('multer');\r\nconst bcrypt = require('bcrypt');\r\n//require('dotenv').config();\r\nconst app = express();\r\nconst port = 5000; // Change to 6000 when you push to GitHub\r\n\r\nconst allowedOrigins = [\r\n    'http://localhost:3000', // Local development frontend\r\n    'http://localhost:3002', // Updated localhost port if needed\r\n    'https://black-desert-0587dbd10.5.azurestaticapps.net/' // Replace with your Azure Static Web App URL\r\n];\r\n\r\napp.use(cors({\r\n    origin: function (origin, callback) {\r\n        if (!origin || allowedOrigins.includes(origin)) {\r\n            callback(null, true);\r\n        } else {\r\n            callback(new Error('Not allowed by CORS'));\r\n        }\r\n    }, credentials: true // Enables credentials if you plan on using them\r\n}));\r\n\r\napp.use(express.json());\r\napp.use(express.static('public')); // Allows access to the public folder for images\r\napp.use(async (req, res, next) => {\r\n    const userId = req.headers['user-id'];\r\n    const role = req.headers['role'];\r\n\r\n    if (userId && role) {\r\n        try {\r\n            // Set session variables for the current connection\r\n            await db.query(`SET @current_user_id = ?`, [userId]);\r\n            await db.query(`SET @current_user_role = ?`, [role]);\r\n        } catch (error) {\r\n            console.error('Error setting session variables:', error);\r\n            // Optionally, you can send an error response here\r\n        }\r\n    }\r\n\r\n    next();\r\n});\r\n\r\n// ----- DATABASE CONNECTION ----------------------------------------------------------------------\r\nconst db = mysql.createPool({ // We can add the env file later so this data is not exposed\r\n    host: process.env.DB_HOST,\r\n    user: process.env.DB_USER,\r\n    password: process.env.DB_PASS,\r\n    database: process.env.DB_NAME,\r\n    port: process.env.DB_PORT,\r\n    waitForConnections: true,\r\n    connectionLimit: 10,\r\n    queueLimit: 0,\r\n    decimalNumbers: true\r\n});\r\ndb.getConnection()\r\n    .then(() => console.log('Connected to the MySQL database'))\r\n    .catch((err) => console.error('Error connecting to the database:', err));\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n// ----- MULTER: IMAGE UPLOAD ---------------------------------------------------------------------\r\nconst storage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n        cb(null, 'public/images');\r\n    }, filename: (req, file, cb) => {\r\n        const safeFileName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n        cb(null, safeFileName);\r\n    }\r\n});\r\nconst upload = multer({storage});\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n// ----- ROLE MAPPINGS -----------------------------------------------------------------------------\r\nconst roleMappings = {\r\n    1: 'admin', 2: 'staff', 3: 'customer', 4: 'member',\r\n};\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n// ----- API CALLS --------------------------------------------------------------------------------\r\n\r\n// ----- (MELANIE) --------------------------------------------------------------------------------\r\n\r\n// rtwork images\r\napp.use('/assets/artworks', express.static(path.join(__dirname, 'assets/artworks')));\r\nconst artworkStorage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n        cb(null, path.join(__dirname, 'assets/artworks')); // Save to frontend/src/assets/artworks\r\n    },\r\n    filename: (req, file, cb) => {\r\n        const safeFileName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n        cb(null, safeFileName);\r\n    }\r\n});\r\nconst uploadArtworkImage = multer({ storage: artworkStorage });\r\n\r\napp.get('/artwork', async (req, res) => {\r\n    try {\r\n        const [result] = await db.query(sql);\r\n        res.json(result);\r\n    } catch (err) {\r\n        console.error('Error fetching artwork:', err);\r\n        res.status(500).json({ message: \"Error fetching artwork table\" });\r\n    }\r\n});\r\n\r\napp.patch('/artwork/:id', uploadArtworkImage.single('image'), async (req, res) => {\r\n    const artworkId = req.params.id;\r\n    const { Title, artist_id, department_id, Description, CreationYear, price, Medium, height, width, depth, acquisition_date, location, ArtworkCondition } = req.body;\r\n    const image = req.file ? req.file.filename : null;\r\n\r\n    // Build the SQL query dynamically based on provided fields\r\n    const fields = [];\r\n    const values = [];\r\n\r\n    if (Title) {\r\n        fields.push('Title = ?');\r\n        values.push(Title);\r\n    }\r\n    if (artist_id) {\r\n        fields.push('artist_id = ?');\r\n        values.push(artist_id);\r\n    }\r\n    if (department_id) {\r\n        fields.push('department_id = ?');\r\n        values.push(department_id);\r\n    }\r\n    if (Description) {\r\n        fields.push('Description = ?');\r\n        values.push(Description);\r\n    }\r\n    if (CreationYear) {\r\n        fields.push('CreationYear = ?');\r\n        values.push(CreationYear);\r\n    }\r\n    if (price !== undefined) {\r\n        fields.push('price = ?');\r\n        values.push(price || null);\r\n    }\r\n    if (Medium) {\r\n        fields.push('Medium = ?');\r\n        values.push(Medium);\r\n    }\r\n    if (height) {\r\n        fields.push('height = ?');\r\n        values.push(height);\r\n    }\r\n    if (width) {\r\n        fields.push('width = ?');\r\n        values.push(width);\r\n    }\r\n    if (depth !== undefined) {\r\n        fields.push('depth = ?');\r\n        values.push(depth || null);\r\n    }\r\n    if (acquisition_date) {\r\n        fields.push('acquisition_date = ?');\r\n        values.push(acquisition_date);\r\n    }\r\n    if (location) {\r\n        fields.push('location = ?');\r\n        values.push(location || null);\r\n    }\r\n    if (ArtworkCondition) {\r\n        fields.push('ArtworkCondition = ?');\r\n        values.push(ArtworkCondition);\r\n    }\r\n    if (image) { // Only update the image if a new one is provided\r\n        fields.push('image = ?');\r\n        values.push(image);\r\n    }\r\n\r\n    if (fields.length === 0) {\r\n        return res.status(400).json({ message: 'No fields to update' });\r\n    }\r\n\r\n    // Add the artworkId to the end of values array for the WHERE clause\r\n    values.push(artworkId);\r\n\r\n    const query = `UPDATE artwork SET ${fields.join(', ')} WHERE ArtworkID = ?`;\r\n\r\n    try {\r\n        await db.query(query, values);\r\n        res.status(200).json({ message: 'Artwork updated successfully.' });\r\n    } catch (error) {\r\n        console.error('Error updating artwork:', error);\r\n        res.status(500).json({ message: 'Server error updating artwork.' });\r\n    }\r\n});\r\n\r\n// only delete artwork\r\napp.delete('/artwork/:id', async (req, res) => {\r\n    const artworkId = req.params.id;\r\n    try {\r\n        await db.query('DELETE FROM artwork WHERE ArtworkID = ?', [artworkId]);\r\n        res.status(200).json({ message: 'Artwork deleted successfully' });\r\n    } catch (error) {\r\n        console.error('Error deleting artwork:', error);\r\n        res.status(500).json({ message: 'Server error deleting artwork' });\r\n    }\r\n});\r\n\r\napp.get('/department', async (req, res) => {\r\n    try {\r\n        const [result] = await db.query(sql);\r\n        res.json(result);\r\n    } catch (err) {\r\n        console.error('Error fetching department:', err);\r\n        res.status(500).json({ message: \"Error fetching department table\" });\r\n    }\r\n});\r\n\r\n// artist images\r\napp.use('/assets/artists', express.static(path.join(__dirname, 'assets/artists')));\r\nconst artistStorage = multer.diskStorage({\r\n    destination: (req, file, cb) => {\r\n      cb(null, path.join(__dirname, 'assets/artists')); // Save to frontend/src/assets/artists\r\n    },\r\n    filename: (req, file, cb) => {\r\n      const safeFileName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n      cb(null, safeFileName);\r\n    }\r\n});\r\nconst uploadArtistImage = multer({ storage: artistStorage });\r\n\r\napp.get('/artist', async (req, res) => {\r\n    try {\r\n        const [result] = await db.query(sql);\r\n        res.json(result);\r\n    } catch (err) {\r\n        console.error('Error fetching artist:', err);\r\n        res.status(500).json({ message: \"Error fetching artist table\" });\r\n    }\r\n});\r\n\r\n// ----- (MELANIE DONE) ---------------------------------------------------------------------------\r\n\r\n// ----- (LEO) ------------------------------------------------------------------------------------\r\n\r\n// User registration\r\napp.post('/register', async (req, res) => {\r\n    const {firstName, lastName, dateOfBirth, username, password, email, roleId} = req.body;\r\n\r\n    const newErrors = {};\r\n    if (!firstName) newErrors.firstName = 'First name is required';\r\n    if (!lastName) newErrors.lastName = 'Last name is required';\r\n    if (!dateOfBirth) newErrors.dateOfBirth = 'Date of birth is required';\r\n    if (!username) newErrors.username = 'Username is required';\r\n    if (!password) newErrors.password = 'Password is required';\r\n    if (!email) newErrors.email = 'Email is required';\r\n\r\n    if (Object.keys(newErrors).length > 0) {\r\n        return res.status(400).json({message: 'Validation error', errors: newErrors});\r\n    }\r\n\r\n    // Assign default role_id if not provided\r\n    const assignedRoleId = roleId || 3; // Default to 'customer' if roleId is not provided\r\n\r\n    // Validate roleId\r\n    if (!Object.keys(roleMappings).includes(String(assignedRoleId))) {\r\n        return res.status(400).json({message: 'Invalid role_id provided.'});\r\n    }\r\n\r\n    try {\r\n        const hashedPassword = await bcrypt.hash(password, 10);\r\n        const sql = `\r\n            INSERT INTO users (first_name, last_name, date_of_birth, username, password, email, role_id)\r\n            VALUES (?, ?, ?, ?, ?, ?, ?)\r\n        `;\r\n        const values = [firstName, lastName, dateOfBirth, username, hashedPassword, email, assignedRoleId];\r\n\r\n        await db.query(sql, values);\r\n        res.status(201).json({message: 'User registered successfully.'});\r\n    } catch (error) {\r\n        console.error('Error during registration:', error);\r\n        res.status(500).json({message: 'Server error during registration.'});\r\n    }\r\n});\r\napp.post('/login', async (req, res) => {\r\n    const {username, password} = req.body;\r\n\r\n    if (!username || !password) {\r\n        return res.status(400).json({message: 'Username and password are required.'});\r\n    }\r\n\r\n    try {\r\n        const [user] = await db.query(`\r\n            SELECT users.*, roles.role_name\r\n            FROM users\r\n            WHERE username = ?\r\n        `, [username]);\r\n\r\n        if (userRows.length === 0) {\r\n            return res.status(400).json({message: 'Invalid username or password.'});\r\n        }\r\n\r\n        const user = userRows[0];\r\n\r\n        // Check if user is deleted\r\n        if (user.is_deleted === 1) {\r\n            return res.status(403).json({message: 'Account has been deactivated. Please contact support.'});\r\n        }\r\n\r\n        const passwordMatch = await bcrypt.compare(password, user.password);\r\n        if (!passwordMatch) {\r\n            return res.status(400).json({ message: 'Invalid username or password.' });\r\n        }\r\n\r\n        // Map role_id to role_name\r\n        const roleName = roleMappings[user.role_id] || 'unknown';\r\n\r\n        res.status(200).json({\r\n            message: 'Login successful!',\r\n            userId: user[0].user_id,\r\n            role: user[0].role_name,\r\n            username: user[0].username, // Include username in response if needed\r\n        });\r\n    } catch (error) {\r\n        console.error('Server error during login:', error);\r\n        res.status(500).json({message: 'Server error.'});\r\n    }\r\n});\r\n// ----- AUTHENTICATION MIDDLEWARE -----\r\n\r\n// Authenticate Admin and Staff Middleware\r\nfunction authenticateAdmin(req, res, next) {\r\n    const {role} = req.headers;\r\n    if (role === 'admin') {\r\n        next();\r\n    } else {\r\n        res.status(403).json({message: 'Access denied. Admins only.'});\r\n    }\r\n}\r\n\r\nasync function authenticateUser(req, res, next) {\r\n    const userId = req.headers['user-id'];\r\n    const role = req.headers['role'];\r\n\r\n    if (userId && role) {\r\n        try {\r\n            const [rows] = await db.query('SELECT is_deleted FROM users WHERE user_id = ?', [userId]);\r\n            if (rows.length > 0 && rows[0].is_deleted === 0) {\r\n                req.userId = userId;\r\n                req.userRole = role;\r\n                next();\r\n            } else {\r\n                res.status(403).json({message: 'Access denied. User is deleted.'});\r\n            }\r\n        } catch (error) {\r\n            console.error('Error in authenticateUser middleware:', error);\r\n            res.status(500).json({message: 'Server error during authentication.'});\r\n        }\r\n    } else {\r\n        res.status(401).json({message: 'Unauthorized access.'});\r\n    }\r\n}\r\n\r\n\r\n// ----- MULTER CONFIGURATION -----\r\nconst uploadMulter = multer({storage: multer.memoryStorage()});\r\n\r\n// ----- GIFT SHOP ITEMS ENDPOINTS -----\r\n\r\n// Create item API\r\napp.post('/giftshopitems', uploadMulter.single('image'), authenticateUser, async (req, res) => {\r\n    const {name_, category, price, quantity} = req.body;\r\n    const imageBlob = req.file ? req.file.buffer : null;\r\n    const imageType = req.file ? req.file.mimetype : null;\r\n\r\n    try {\r\n        const sql = `\r\n            INSERT INTO giftshopitem (name_, category, price, quantity, image, image_type)\r\n            VALUES (?, ?, ?, ?, ?, ?)\r\n        `;\r\n        const values = [name_, category, parseFloat(price), parseInt(quantity, 10), imageBlob, imageType];\r\n        // No cache\r\n        res.set('Cache-Control', 'no-store');\r\n        await db.query(sql, values);\r\n        res.status(201).json({message: 'Item created successfully'});\r\n    } catch (error) {\r\n        console.error('Error creating gift shop item:', error);\r\n        res.status(500).json({error: 'Failed to create gift shop item'});\r\n    }\r\n});\r\n// Get all gift shop items (non-deleted)\r\napp.get('/giftshopitems', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT item_id, name_, category, price, quantity, is_deleted FROM giftshopitem WHERE is_deleted = 0');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching gift shop items:', error);\r\n        res.status(500).json({message: 'Server error fetching gift shop items.'});\r\n    }\r\n});\r\n\r\n// Get all gift shop items (including deleted, admin only)\r\napp.get('/giftshopitemsall', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT item_id, name_, category, price, quantity, is_deleted FROM giftshopitem');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching gift shop items:', error);\r\n        res.status(500).json({message: 'Server error fetching gift shop items.'});\r\n    }\r\n});\r\n\r\n// Get image for a specific gift shop item\r\napp.get('/giftshopitems/:id/image', async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const [rows] = await db.query('SELECT image, image_type FROM giftshopitem WHERE item_id = ?', [id]);\r\n        if (rows.length === 0 || !rows[0].image) {\r\n            return res.status(404).json({message: 'Image not found.'});\r\n        }\r\n\r\n        const imageType = rows[0].image_type || 'application/octet-stream';\r\n        res.set('Content-Type', imageType);\r\n        res.send(rows[0].image);\r\n    } catch (error) {\r\n        console.error('Error fetching image:', error);\r\n        res.status(500).json({message: 'Server error fetching image.'});\r\n    }\r\n});\r\n\r\n// Update item API\r\n// Update item API\r\napp.put('/giftshopitems/:id', uploadMulter.single('image'), authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n    const {name_, category, price, quantity} = req.body;\r\n    const imageBlob = req.file ? req.file.buffer : null;\r\n    const imageType = req.file ? req.file.mimetype : null;\r\n\r\n    try {\r\n        let sql, values;\r\n\r\n        if (imageBlob && imageType) {\r\n            sql = `\r\n                UPDATE giftshopitem\r\n                SET name_      = ?,\r\n                    category   = ?,\r\n                    price      = ?,\r\n                    quantity   = ?,\r\n                    image      = ?,\r\n                    image_type = ?\r\n                WHERE item_id = ?\r\n                  AND is_deleted = 0\r\n            `;\r\n            values = [name_, category, parseFloat(price), quantity, imageBlob, imageType, id];\r\n        } else {\r\n            // If no new image is uploaded, don't update image fields\r\n            sql = `\r\n                UPDATE giftshopitem\r\n                SET name_    = ?,\r\n                    category = ?,\r\n                    price    = ?,\r\n                    quantity = ?\r\n                WHERE item_id = ?\r\n                  AND is_deleted = 0\r\n            `;\r\n            values = [name_, category, parseFloat(price), quantity, id];\r\n        }\r\n        res.set('Cache-Control', 'no-store');\r\n        const [result] = await db.query(sql, values);\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Item not found or already deleted.'});\r\n        }\r\n        res.status(200).json({message: 'Item updated successfully'});\r\n    } catch (error) {\r\n        console.error('Error updating gift shop item:', error);\r\n        res.status(500).json({error: 'Failed to update gift shop item'});\r\n    }\r\n});\r\n\r\n\r\n// Hard delete a gift shop item (Admin only)\r\napp.delete('/giftshopitems/:id/hard-delete', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'DELETE FROM giftshopitem WHERE item_id = ?';\r\n        const [result] = await db.query(sql, [id]);\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Item not found or already deleted.'});\r\n        }\r\n\r\n        res.status(200).json({message: 'Gift shop item permanently deleted.'});\r\n    } catch (error) {\r\n        console.error('Error hard deleting gift shop item:', error);\r\n        res.status(500).json({message: 'Server error during hard delete.'});\r\n    }\r\n});\r\n\r\n\r\n// Soft delete a gift shop item (Admin only)\r\napp.put('/giftshopitems/:id/soft-delete', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'UPDATE giftshopitem SET is_deleted = 1 WHERE item_id = ?';\r\n        await db.query(sql, [id]);\r\n        res.status(200).json({message: 'Gift shop item marked as deleted.'});\r\n    } catch (error) {\r\n        console.error('Error soft deleting gift shop item:', error);\r\n        res.status(500).json({message: 'Server error soft deleting gift shop item.'});\r\n    }\r\n});\r\n\r\n// Soft delete a gift shop item (Admin only)\r\napp.put('/giftshopitems/:id/soft-delete', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'UPDATE giftshopitem SET is_deleted = 1 WHERE item_id = ?';\r\n        await db.query(sql, [id]);\r\n        res.status(200).json({message: 'Gift shop item marked as deleted.'});\r\n    } catch (error) {\r\n        console.error('Error soft deleting gift shop item:', error);\r\n        res.status(500).json({message: 'Server error soft deleting gift shop item.'});\r\n    }\r\n});\r\n\r\n/// Get all users (Admin only)\r\napp.get('/users', authenticateAdmin, async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query(`\r\n            SELECT user_id,\r\n                   first_name,\r\n                   last_name,\r\n                   username,\r\n                   email,\r\n                   role_id,\r\n                   is_deleted,\r\n                   DATE_FORMAT(date_of_birth, '%Y-%m-%d') AS date_of_birth\r\n            FROM users\r\n        `);\r\n\r\n        // Map role_id to role_name\r\n        const users = rows.map(user => ({\r\n            ...user, role_name: roleMappings[user.role_id],\r\n        }));\r\n\r\n        res.status(200).json(users);\r\n    } catch (error) {\r\n        console.error('Error fetching users:', error);\r\n        res.status(500).json({message: 'Server error fetching users.'});\r\n    }\r\n});\r\napp.get('/giftshopitems/logs', authenticateAdmin, async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query(`\r\n            SELECT l.*, u.username\r\n            FROM giftshopitem_log l\r\n                     LEFT JOIN users u ON l.user_id = u.user_id\r\n            ORDER BY l.timestamp DESC\r\n        `);\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching gift shop item logs:', error);\r\n        res.status(500).json({message: 'Server error fetching logs.'});\r\n    }\r\n});\r\n// Get user profile\r\napp.get('/users/:id', authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    // Ensure the user can only access their own profile or admin can access any\r\n    if (req.userId !== id && req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied.'});\r\n    }\r\n\r\n    try {\r\n        const [rows] = await db.query(`\r\n            SELECT first_name AS firstName, last_name AS lastName, date_of_birth AS dateOfBirth, username, email\r\n            FROM users\r\n            WHERE user_id = ?\r\n              AND is_deleted = 0\r\n        `, [id]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({message: 'User not found.'});\r\n        }\r\n\r\n        res.json(rows[0]);\r\n    } catch (error) {\r\n        console.error('Error fetching user data:', error);\r\n        res.status(500).json({message: 'Server error fetching user data.'});\r\n    }\r\n});\r\n// Update user (Admin only)\r\napp.put('/users/:id', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n    const {firstName, lastName, dateOfBirth, email, roleId} = req.body;\r\n\r\n    try {\r\n        const sql = `\r\n            UPDATE users\r\n            SET first_name    = ?,\r\n                last_name     = ?,\r\n                date_of_birth = ?,\r\n                email         = ?,\r\n                role_id       = ?\r\n            WHERE user_id = ?\r\n        `;\r\n        const values = [firstName, lastName, dateOfBirth, email, roleId, id];\r\n\r\n        await db.query(sql, values);\r\n        res.status(200).json({message: 'User updated successfully.'});\r\n    } catch (error) {\r\n        console.error('Error updating user:', error);\r\n        res.status(500).json({message: 'Server error updating user.'});\r\n    }\r\n});\r\n\r\n// Soft delete user (Admin only)\r\napp.put('/users/:id/soft-delete', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'UPDATE users SET is_deleted = 1 WHERE user_id = ?';\r\n        await db.query(sql, [id]);\r\n        res.status(200).json({message: 'User soft deleted successfully.'});\r\n    } catch (error) {\r\n        console.error('Error soft deleting user:', error);\r\n        res.status(500).json({message: 'Server error soft deleting user.'});\r\n    }\r\n});\r\n\r\n// Hard delete user (Admin only)\r\napp.delete('/users/:id', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'DELETE FROM users WHERE user_id = ?';\r\n        await db.query(sql, [id]);\r\n        res.status(200).json({message: 'User hard deleted successfully.'});\r\n    } catch (error) {\r\n        console.error('Error hard deleting user:', error);\r\n        res.status(500).json({message: 'Server error hard deleting user.'});\r\n    }\r\n});\r\n\r\n// Restore a gift shop item (Admin only)\r\napp.put('/giftshopitems/:id/restore', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    try {\r\n        const sql = 'UPDATE giftshopitem SET is_deleted = 0 WHERE item_id = ?';\r\n        await db.query(sql, [id]);\r\n        res.status(200).json({message: 'Gift shop item restored successfully.'});\r\n    } catch (error) {\r\n        console.error('Error restoring gift shop item:', error);\r\n        res.status(500).json({message: 'Server error restoring gift shop item.'});\r\n    }\r\n});\r\n\r\n// ----- CHECKOUT ENDPOINT ------------------------------------------------------------------------\r\napp.put('/users/:id/change-password', authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n    const {currentPassword, newPassword} = req.body;\r\n\r\n    // Ensure the user can only change their own password or admin can change any\r\n    if (req.userId !== id && req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. You can only change your own password.'});\r\n    }\r\n\r\n    try {\r\n        const [rows] = await db.query('SELECT password FROM users WHERE user_id = ?', [id]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({message: 'User not found.'});\r\n        }\r\n\r\n        const user = rows[0];\r\n        const isMatch = await bcrypt.compare(currentPassword, user.password);\r\n        if (!isMatch) {\r\n            return res.status(400).json({message: 'Current password is incorrect.'});\r\n        }\r\n\r\n        // Additional Validation: Check if newPassword meets criteria (e.g., length)\r\n        if (newPassword.length < 6) {\r\n            return res.status(400).json({message: 'New password must be at least 6 characters long.'});\r\n        }\r\n\r\n        const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n        await db.query('UPDATE users SET password = ? WHERE user_id = ?', [hashedPassword, id]);\r\n\r\n        res.status(200).json({message: 'Password updated successfully!'});\r\n    } catch (error) {\r\n        console.error('Error updating password:', error);\r\n        res.status(500).json({message: 'Server error updating password.'});\r\n    }\r\n});\r\n// Admin reset password endpoint\r\napp.put('/users/:id/reset-password', authenticateAdmin, async (req, res) => {\r\n    const {id} = req.params;\r\n    const {newPassword} = req.body;\r\n\r\n    // Validate the new password\r\n    if (!newPassword || newPassword.length < 6) {\r\n        return res.status(400).json({message: 'New password must be at least 6 characters long.'});\r\n    }\r\n\r\n    try {\r\n        // Check if the user exists\r\n        const [rows] = await db.query('SELECT * FROM users WHERE user_id = ?', [id]);\r\n\r\n        if (rows.length === 0) {\r\n            return res.status(404).json({message: 'User not found.'});\r\n        }\r\n\r\n        // Hash the new password\r\n        const hashedPassword = await bcrypt.hash(newPassword, 10);\r\n\r\n        // Update the user's password\r\n        await db.query('UPDATE users SET password = ? WHERE user_id = ?', [hashedPassword, id]);\r\n\r\n        res.status(200).json({message: 'Password reset successfully!'});\r\n    } catch (error) {\r\n        console.error('Error resetting password:', error);\r\n        res.status(500).json({message: 'Server error resetting password.'});\r\n    }\r\n});\r\n// ----- CHECKOUT ENDPOINT (Assuming other checkout logic is implemented)\r\napp.post('/checkout', authenticateUser, async (req, res) => {\r\n    const {payment_method, items} = req.body;\r\n    const user_id = req.userId; // Retrieved from the authenticateUser middleware\r\n\r\n    // Input Validation\r\n    if (!payment_method || !items || !Array.isArray(items) || items.length === 0) {\r\n        return res.status(400).json({message: 'Invalid request. payment_method and items are required.'});\r\n    }\r\n\r\n    for (let item of items) {\r\n        if (!item.item_id || !item.quantity || item.quantity <= 0) {\r\n            return res.status(400).json({message: 'Each item must have a valid item_id and quantity greater than 0.'});\r\n        }\r\n    }\r\n\r\n    const connection = await db.getConnection();\r\n    try {\r\n        await connection.beginTransaction();\r\n\r\n        // Fetch item details with row locking to prevent race conditions\r\n        const itemIds = items.map(item => item.item_id);\r\n        const [dbItems] = await connection.query(`SELECT item_id, price, quantity\r\n                                                  FROM giftshopitem\r\n                                                  WHERE item_id IN (?)\r\n                                                    AND is_deleted = 0\r\n                                                      FOR UPDATE`, [itemIds]);\r\n\r\n        // Check if all items exist\r\n        if (dbItems.length !== items.length) {\r\n            throw new Error('One or more items do not exist or have been deleted.');\r\n        }\r\n\r\n        // Check for sufficient inventory and prepare transaction items\r\n        let calculatedSubtotal = 0;\r\n        const transactionItems = [];\r\n\r\n        for (let cartItem of items) {\r\n            const dbItem = dbItems.find(item => item.item_id === cartItem.item_id);\r\n            if (dbItem.quantity < cartItem.quantity) {\r\n                throw new Error(`Insufficient quantity for item '${dbItem.item_id}'. Available: ${dbItem.quantity}, Requested: ${cartItem.quantity}.`);\r\n            }\r\n            const itemSubtotal = parseFloat((cartItem.quantity * dbItem.price).toFixed(2));\r\n            calculatedSubtotal += itemSubtotal;\r\n            transactionItems.push({\r\n                item_id: cartItem.item_id,\r\n                quantity: cartItem.quantity,\r\n                price_at_purchase: dbItem.price,\r\n                subtotal: itemSubtotal\r\n            });\r\n        }\r\n\r\n        calculatedSubtotal = parseFloat(calculatedSubtotal.toFixed(2));\r\n        const taxRate = 0.0825; // 8.25% tax\r\n        const calculatedTax = parseFloat((calculatedSubtotal * taxRate).toFixed(2));\r\n        const calculatedTotal = parseFloat((calculatedSubtotal + calculatedTax).toFixed(2));\r\n\r\n        // Insert into transaction table\r\n        const [transactionResult] = await connection.query(`INSERT INTO \\`transaction\\` (transaction_date, subtotal,\r\n                                                                                         tax, total_amount,\r\n                                                                                         transaction_type, user_id,\r\n                                                                                         payment_status)\r\n                                                            VALUES (NOW(), ?, ?, ?, ?, ?,\r\n                                                                    ?)`, [calculatedSubtotal, calculatedTax, calculatedTotal, payment_method, user_id, 'completed']);\r\n        const transactionId = transactionResult.insertId;\r\n\r\n        // Insert into transaction_giftshopitem table\r\n        const transactionItemsValues = transactionItems.map(item => [transactionId, item.item_id, item.quantity, item.price_at_purchase]);\r\n\r\n        await connection.query(`INSERT INTO \\`transaction_giftshopitem\\` (transaction_id, item_id, quantity, price_at_purchase)\r\n                                VALUES ?`, [transactionItemsValues]);\r\n\r\n        // Update giftshopitem quantities\r\n        for (let cartItem of items) {\r\n            await connection.query(`UPDATE giftshopitem\r\n                                    SET quantity = quantity - ?\r\n                                    WHERE item_id = ?`, [cartItem.quantity, cartItem.item_id]);\r\n        }\r\n\r\n        // Commit the transaction\r\n        await connection.commit();\r\n\r\n        res.status(201).json({\r\n            success: true, message: 'Checkout successful.', transaction_id: transactionId, total_amount: calculatedTotal\r\n        });\r\n\r\n    } catch (error) {\r\n        await connection.rollback();\r\n        console.error('Checkout Error:', error.message);\r\n        res.status(400).json({success: false, message: error.message});\r\n    } finally {\r\n        connection.release();\r\n    }\r\n});\r\n\r\n// Updated /reports endpoint\r\napp.post('/reports', authenticateAdmin, async (req, res) => {\r\n    const {\r\n        report_category, report_type, report_period_type, // 'date_range', 'month', 'year', or 'single_day'\r\n        start_date, end_date, selected_month, selected_year, // New field for 'year' report\r\n        selected_date, // New field for 'single_day' report\r\n        item_category, payment_method, item_id,\r\n    } = req.body;\r\n\r\n    console.log('Received /reports request with body:', req.body); // Debug log\r\n\r\n    // Input Validation\r\n    if (!report_category || !report_type || !report_period_type) {\r\n        console.error('Validation Error: Missing required fields.');\r\n        return res.status(400).json({\r\n            message: 'report_category, report_type, and report_period_type are required.',\r\n        });\r\n    }\r\n\r\n    // Validate report_period_type and corresponding fields\r\n    if (report_period_type === 'date_range') {\r\n        if (!start_date || !end_date) {\r\n            console.error('Validation Error: Start date and end date are required.');\r\n            return res.status(400).json({\r\n                message: 'Start date and end date are required for date range reports.',\r\n            });\r\n        }\r\n        if (new Date(start_date) > new Date(end_date)) {\r\n            console.error('Validation Error: Start date is after end date.');\r\n            return res.status(400).json({message: 'Start date cannot be after end date.'});\r\n        }\r\n    } else if (report_period_type === 'month') {\r\n        if (!selected_month) {\r\n            console.error('Validation Error: Selected month is required.');\r\n            return res.status(400).json({\r\n                message: 'Selected month is required for monthly reports.',\r\n            });\r\n        }\r\n    } else if (report_period_type === 'year') {\r\n        if (!selected_year) {\r\n            console.error('Validation Error: Selected year is required.');\r\n            return res.status(400).json({\r\n                message: 'Selected year is required for yearly reports.',\r\n            });\r\n        }\r\n    } else if (report_period_type === 'single_day') {\r\n        if (!selected_date) {\r\n            console.error('Validation Error: Selected date is required.');\r\n            return res.status(400).json({\r\n                message: 'Selected date is required for single day reports.',\r\n            });\r\n        }\r\n    } else {\r\n        console.error('Invalid report_period_type:', report_period_type);\r\n        return res.status(400).json({message: 'Invalid report period type.'});\r\n    }\r\n\r\n    try {\r\n        let reportData;\r\n        if (report_category === 'GiftShopReport') {\r\n            switch (report_type) {\r\n                case 'revenue':\r\n                    console.log('Generating Gift Shop Revenue Report');\r\n                    reportData = await generateGiftShopRevenueReport(report_period_type, start_date, end_date, selected_month, selected_year, selected_date, item_category, payment_method, item_id);\r\n                    console.log('Report Data:', reportData); // Debug log\r\n                    break;\r\n                case 'transaction_details':\r\n                    console.log('Generating Gift Shop Transaction Details Report');\r\n                    reportData = await generateGiftShopTransactionDetailsReport(report_period_type, start_date, end_date, selected_month, selected_year, selected_date, item_category, payment_method, item_id);\r\n                    console.log('Report Data:', reportData);\r\n                    break;\r\n                // Add other report types if needed\r\n                default:\r\n                    console.error('Invalid report type:', report_type);\r\n                    return res.status(400).json({message: 'Invalid report type.'});\r\n            }\r\n        } else {\r\n            console.error('Invalid report category:', report_category);\r\n            return res.status(400).json({message: 'Invalid report category.'});\r\n        }\r\n\r\n        res.status(200).json({reportData});\r\n    } catch (error) {\r\n        console.error('Error generating report:', error); // Debug log with error details\r\n        res.status(500).json({message: 'Server error generating report.'});\r\n    }\r\n});\r\n\r\n// Updated Function to generate Gift Shop Revenue Report with filters\r\nasync function generateGiftShopRevenueReport(reportPeriodType, startDate, endDate, selectedMonth, selectedYear, selectedDate, itemCategory, paymentMethod, itemId) {\r\n    let query = '';\r\n    let params = [];\r\n\r\n    if (reportPeriodType === 'date_range') {\r\n        // SQL query for date range\r\n        query = `\r\n            SELECT DATE (t.transaction_date) AS date, SUM (tgi.quantity * tgi.price_at_purchase) AS total_revenue\r\n            FROM \\`transaction\\` t\r\n                JOIN transaction_giftshopitem tgi\r\n            ON t.transaction_id = tgi.transaction_id\r\n                JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id\r\n            WHERE t.transaction_date >= ? AND t.transaction_date < DATE_ADD(?, INTERVAL 1 DAY)\r\n        `;\r\n        params = [startDate, endDate];\r\n    } else if (reportPeriodType === 'month') {\r\n        // SQL query for month - daily data within the selected month\r\n        query = `\r\n            SELECT DATE (t.transaction_date) AS date, SUM (tgi.quantity * tgi.price_at_purchase) AS total_revenue\r\n            FROM \\`transaction\\` t\r\n                JOIN transaction_giftshopitem tgi\r\n            ON t.transaction_id = tgi.transaction_id\r\n                JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id\r\n            WHERE DATE_FORMAT(t.transaction_date, '%Y-%m') = ?\r\n        `;\r\n        params = [selectedMonth];\r\n    } else if (reportPeriodType === 'year') {\r\n        // SQL query for year - monthly data within the selected year\r\n        query = `\r\n            SELECT DATE_FORMAT(t.transaction_date, '%Y-%m') AS date, SUM(tgi.quantity * tgi.price_at_purchase) AS total_revenue\r\n            FROM \\`transaction\\` t\r\n                JOIN transaction_giftshopitem tgi\r\n            ON t.transaction_id = tgi.transaction_id\r\n                JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id\r\n            WHERE YEAR (t.transaction_date) = ?\r\n        `;\r\n        params = [selectedYear];\r\n        } else if (reportPeriodType === 'single_day') {\r\n            query = `\r\n                SELECT t.transaction_id,\r\n                       t.transaction_date,\r\n                       t.transaction_type,\r\n                       t.payment_status,\r\n                       u.username,\r\n                       tgi.item_id,\r\n                       gsi.name_                              as item_name,\r\n                       tgi.quantity,\r\n                       tgi.price_at_purchase,\r\n                       (tgi.quantity * tgi.price_at_purchase) as item_total\r\n                FROM \\`transaction\\` t\r\n                         JOIN transaction_giftshopitem tgi ON t.transaction_id = tgi.transaction_id\r\n                         JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id\r\n                         JOIN users u ON t.user_id = u.user_id\r\n                WHERE DATE (t.transaction_date) = ?\r\n            `;\r\n            params = [selectedDate];\r\n    } else {\r\n        throw new Error('Invalid report period type for transaction details report.');\r\n    }\r\n\r\n// Apply filters if provided\r\n    if (paymentMethod) {\r\n        query += ' AND t.transaction_type = ?';\r\n        params.push(paymentMethod);\r\n    }\r\n    if (itemCategory) {\r\n        query += ' AND gsi.category = ?';\r\n        params.push(itemCategory);\r\n    }\r\n    if (itemId) {\r\n        query += ' AND tgi.item_id = ?';\r\n        params.push(itemId);\r\n    }\r\n\r\n// Group by appropriate time period\r\n    if (reportPeriodType === 'date_range' || reportPeriodType === 'month') {\r\n        query += `\r\n            GROUP BY DATE(t.transaction_date)\r\n            ORDER BY DATE(t.transaction_date)\r\n        `;\r\n    } else if (reportPeriodType === 'year') {\r\n        query += `\r\n            GROUP BY DATE_FORMAT(t.transaction_date, '%Y-%m')\r\n            ORDER BY DATE_FORMAT(t.transaction_date, '%Y-%m')\r\n        `;\r\n    }\r\n\r\n    console.log('Executing SQL Query for Revenue Report:', query); // Debug log\r\n    console.log('With Parameters:', params); // Debug log\r\n\r\n    try {\r\n        const [rows] = await db.query(query, params);\r\n        console.log('Revenue Report Query Result:', rows); // Debug log\r\n        return rows;\r\n    } catch (error) {\r\n        console.error('Error in generateGiftShopRevenueReport:', error); // Debug log with error details\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Endpoint to get all gift shop items\r\napp.get('/giftshopitems', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT item_id, name_ FROM giftshopitem WHERE is_deleted = 0');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching gift shop items:', error);\r\n        res.status(500).json({message: 'Server error fetching gift shop items.'});\r\n    }\r\n});\r\n\r\n// Endpoint to get all gift shop categories\r\napp.get('/giftshopcategories', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT DISTINCT category FROM giftshopitem WHERE is_deleted = 0');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching item categories:', error);\r\n        res.status(500).json({message: 'Server error fetching item categories.'});\r\n    }\r\n});\r\n\r\n// Endpoint to get all payment methods used in transactions\r\napp.get('/paymentmethods', async (req, res) => {\r\n    try {\r\n        const [rows] = await db.query('SELECT DISTINCT transaction_type FROM `transaction`');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching payment methods:', error);\r\n        res.status(500).json({message: 'Server error fetching payment methods.'});\r\n    }\r\n});\r\n// Create a new announcement (Admin only)\r\napp.post('/announcements', authenticateUser, async (req, res) => {\r\n    const {title, content, target_audience, priority} = req.body;\r\n\r\n    // Only admin can create announcements\r\n    if (req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. Only admins can create announcements.'});\r\n    }\r\n\r\n    // Validate inputs\r\n    if (!title || !content || !target_audience || !priority) {\r\n        return res.status(400).json({message: 'Title, content, target audience, and priority are required.'});\r\n    }\r\n\r\n    // Validate target_audience\r\n    const validAudiences = ['staff', 'member', 'customer', 'all'];\r\n    if (!validAudiences.includes(target_audience)) {\r\n        return res.status(400).json({message: 'Invalid target audience.'});\r\n    }\r\n\r\n    // Validate priority\r\n    const validPriorities = ['high', 'medium', 'low'];\r\n    if (!validPriorities.includes(priority)) {\r\n        return res.status(400).json({message: 'Invalid priority value.'});\r\n    }\r\n\r\n    try {\r\n        const sql = `\r\n            INSERT INTO announcements (title, content, target_audience, priority)\r\n            VALUES (?, ?, ?, ?)\r\n        `;\r\n        const values = [title, content, target_audience, priority];\r\n        await db.query(sql, values);\r\n        res.status(201).json({message: 'Announcement created successfully.'});\r\n    } catch (error) {\r\n        console.error('Error creating announcement:', error);\r\n        res.status(500).json({message: 'Server error creating announcement.'});\r\n    }\r\n});\r\n\r\n// Get all announcements (including deleted) for admin\r\napp.get('/announcements/all', authenticateUser, async (req, res) => {\r\n    // Only admins can access this endpoint\r\n    if (req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. Admins only.'});\r\n    }\r\n\r\n    try {\r\n        const [rows] = await db.query('SELECT * FROM announcements ORDER BY created_at DESC');\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching announcements:', error);\r\n        res.status(500).json({message: 'Server error fetching announcements.'});\r\n    }\r\n});\r\n\r\n// Get announcements for a user based on their role\r\napp.get('/announcements/user', authenticateUser, async (req, res) => {\r\n    const {userRole} = req;\r\n\r\n    try {\r\n        const sql = `\r\n            SELECT *\r\n            FROM announcements\r\n            WHERE (target_audience = ? OR target_audience = 'all')\r\n              AND is_active = 1\r\n            ORDER BY created_at DESC\r\n        `;\r\n        const values = [userRole];\r\n\r\n        const [rows] = await db.query(sql, values);\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching user announcements:', error);\r\n        res.status(500).json({message: 'Server error fetching announcements.'});\r\n    }\r\n});\r\n\r\n// Update an announcement (Admin only)\r\napp.put('/announcements/:id', authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n    const {title, content, target_audience, priority} = req.body;\r\n\r\n    // Only admin can update announcements\r\n    if (req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. Only admins can update announcements.'});\r\n    }\r\n\r\n    // Validate inputs\r\n    if (!title || !content || !target_audience || !priority) {\r\n        return res.status(400).json({message: 'Title, content, target audience, and priority are required.'});\r\n    }\r\n\r\n    // Validate target_audience\r\n    const validAudiences = ['staff', 'member', 'customer', 'all'];\r\n    if (!validAudiences.includes(target_audience)) {\r\n        return res.status(400).json({message: 'Invalid target audience.'});\r\n    }\r\n\r\n    // Validate priority\r\n    const validPriorities = ['high', 'medium', 'low'];\r\n    if (!validPriorities.includes(priority)) {\r\n        return res.status(400).json({message: 'Invalid priority value.'});\r\n    }\r\n\r\n    try {\r\n        const sql = `\r\n            UPDATE announcements\r\n            SET title           = ?,\r\n                content         = ?,\r\n                target_audience = ?,\r\n                priority        = ?\r\n            WHERE id = ?\r\n        `;\r\n        const values = [title, content, target_audience, priority, id];\r\n\r\n        const [result] = await db.query(sql, values);\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Announcement not found.'});\r\n        }\r\n\r\n        res.json({message: 'Announcement updated successfully.'});\r\n    } catch (error) {\r\n        console.error('Error updating announcement:', error);\r\n        res.status(500).json({message: 'Server error updating announcement.'});\r\n    }\r\n});\r\n\r\n// Soft delete an announcement (Admin only)\r\napp.delete('/announcements/:id', authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    // Only admin can delete announcements\r\n    if (req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. Only admins can delete announcements.'});\r\n    }\r\n\r\n    try {\r\n        const sql = `\r\n            UPDATE announcements\r\n            SET is_active = 0\r\n            WHERE id = ?\r\n        `;\r\n        const [result] = await db.query(sql, [id]);\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Announcement not found.'});\r\n        }\r\n\r\n        res.json({message: 'Announcement deleted successfully.'});\r\n    } catch (error) {\r\n        console.error('Error deleting announcement:', error);\r\n        res.status(500).json({message: 'Server error deleting announcement.'});\r\n    }\r\n});\r\n\r\n// Restore a soft-deleted announcement (Admin only)\r\napp.put('/announcements/:id/restore', authenticateUser, async (req, res) => {\r\n    const {id} = req.params;\r\n\r\n    // Only admin can restore announcements\r\n    if (req.userRole !== 'admin') {\r\n        return res.status(403).json({message: 'Access denied. Only admins can restore announcements.'});\r\n    }\r\n\r\n    try {\r\n        const sql = `\r\n            UPDATE announcements\r\n            SET is_active = 1\r\n            WHERE id = ?\r\n        `;\r\n        const [result] = await db.query(sql, [id]);\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Announcement not found.'});\r\n        }\r\n\r\n        res.json({message: 'Announcement restored successfully.'});\r\n    } catch (error) {\r\n        console.error('Error restoring announcement:', error);\r\n        res.status(500).json({message: 'Server error restoring announcement.'});\r\n    }\r\n});\r\n// Endpoint to handle ticket purchases\r\n// Endpoint to handle ticket purchases\r\napp.post('/ticket-purchase', async (req, res) => {\r\n    const { payment_method, tickets } = req.body;\r\n    const user_id = req.userId; // Retrieved from the authenticateUser middleware\r\n\r\n    // Input Validation\r\n    if (!payment_method || !tickets || !Array.isArray(tickets) || tickets.length === 0) {\r\n        return res.status(400).json({ message: 'Invalid request. payment_method and tickets are required.' });\r\n    }\r\n\r\n    for (let ticket of tickets) {\r\n        if (!ticket.ticket_type_id || !ticket.quantity || ticket.quantity <= 0 || !ticket.visit_date) {\r\n            return res.status(400).json({ message: 'Each ticket must have a valid ticket_type_id, quantity greater than 0, and visit_date.' });\r\n        }\r\n    }\r\n\r\n    const connection = await db.getConnection();\r\n    try {\r\n        await connection.beginTransaction();\r\n\r\n        // Fetch ticket types with current prices\r\n        const ticketTypeIds = tickets.map(ticket => ticket.ticket_type_id);\r\n        const [dbTickets] = await connection.query(\r\n            `SELECT ticket_type_id, price FROM ticket WHERE ticket_type_id IN (?)`,\r\n            [ticketTypeIds]\r\n        );\r\n\r\n        // Check if all ticket types exist\r\n        if (dbTickets.length !== tickets.length) {\r\n            throw new Error('One or more ticket types do not exist.');\r\n        }\r\n\r\n        let calculatedSubtotal = 0;\r\n        const transactionTickets = [];\r\n\r\n        for (let cartTicket of tickets) {\r\n            const dbTicket = dbTickets.find(ticket => ticket.ticket_type_id === cartTicket.ticket_type_id);\r\n            const ticketSubtotal = parseFloat((cartTicket.quantity * dbTicket.price).toFixed(2));\r\n            calculatedSubtotal += ticketSubtotal;\r\n            transactionTickets.push({\r\n                ticket_type_id: cartTicket.ticket_type_id,\r\n                quantity: cartTicket.quantity,\r\n                price_at_purchase: dbTicket.price,\r\n                subtotal: ticketSubtotal,\r\n                visit_date: cartTicket.visit_date,\r\n            });\r\n        }\r\n\r\n        calculatedSubtotal = parseFloat(calculatedSubtotal.toFixed(2));\r\n        const taxRate = 0.0825; // 8.25% tax\r\n        const calculatedTax = parseFloat((calculatedSubtotal * taxRate).toFixed(2));\r\n        const calculatedTotal = parseFloat((calculatedSubtotal + calculatedTax).toFixed(2));\r\n\r\n        // Insert into transaction table\r\n        const [transactionResult] = await connection.query(\r\n            `INSERT INTO \\`transaction\\` (transaction_date, subtotal, tax, total_amount, transaction_type, user_id, payment_status)\r\n             VALUES (NOW(), ?, ?, ?, ?, ?, ?)`,\r\n            [calculatedSubtotal, calculatedTax, calculatedTotal, payment_method, user_id, 'completed']\r\n        );\r\n        const transactionId = transactionResult.insertId;\r\n\r\n        // Insert into transaction_ticket table\r\n        const transactionTicketsValues = transactionTickets.map(ticket => [\r\n            transactionId,\r\n            ticket.ticket_type_id,\r\n            ticket.quantity,\r\n            ticket.price_at_purchase,\r\n        ]);\r\n        await connection.query(\r\n            `INSERT INTO transaction_ticket (transaction_id, ticket_type_id, quantity, price_at_purchase)\r\n             VALUES ?`,\r\n            [transactionTicketsValues]\r\n        );\r\n\r\n        // Insert individual tickets into bought_tickets\r\n        const boughtTicketsValues = [];\r\n        for (let ticket of transactionTickets) {\r\n            for (let i = 0; i < ticket.quantity; i++) {\r\n                boughtTicketsValues.push([\r\n                    ticket.ticket_type_id,\r\n                    user_id,\r\n                    transactionId,\r\n                    ticket.visit_date,\r\n                    ticket.price_at_purchase,\r\n                ]);\r\n            }\r\n        }\r\n        await connection.query(\r\n            `INSERT INTO bought_tickets (ticket_type_id, user_id, transaction_id, visit_date, price_at_purchase)\r\n       VALUES ?`,\r\n            [boughtTicketsValues]\r\n        );\r\n\r\n        // Commit the transaction\r\n        await connection.commit();\r\n\r\n        res.status(201).json({\r\n            success: true,\r\n            message: 'Ticket purchase successful.',\r\n            transaction_id: transactionId,\r\n            total_amount: calculatedTotal,\r\n        });\r\n    } catch (error) {\r\n        await connection.rollback();\r\n        console.error('Ticket Purchase Error:', error.message);\r\n        res.status(400).json({ success: false, message: error.message });\r\n    } finally {\r\n        connection.release();\r\n    }\r\n});\r\n\r\napp.get('/users/:id/tickets', async (req, res) => {\r\n    const userId = req.params.id;\r\n\r\n    try {\r\n        const query = `\r\n            SELECT\r\n                bt.ticket_id,\r\n                bt.ticket_type_id,\r\n                bt.visit_date,\r\n                bt.price_at_purchase,\r\n                t.admission_type,\r\n                t.price_category,\r\n                tr.transaction_date,\r\n                tr.transaction_id\r\n            FROM bought_tickets bt\r\n                     JOIN ticket t ON bt.ticket_type_id = t.ticket_type_id\r\n                     JOIN \\`transaction\\` tr ON bt.transaction_id = tr.transaction_id\r\n            WHERE bt.user_id = ?\r\n            ORDER BY bt.visit_date DESC\r\n        `;\r\n        const [rows] = await db.query(query, [userId]);\r\n        res.status(200).json(rows);\r\n    } catch (error) {\r\n        console.error('Error fetching user tickets:', error);\r\n        res.status(500).json({ message: 'Server error fetching user tickets.' });\r\n    }\r\n});\r\n// Server-side code to fetch ticket types\r\napp.get('/ticket-types', async (req, res) => {\r\n    try {\r\n        const [ticketTypes] = await db.query('SELECT * FROM ticket');\r\n        res.json(ticketTypes);\r\n    } catch (error) {\r\n        console.error('Error fetching ticket types:', error);\r\n        res.status(500).json({ message: 'Server error fetching ticket types.' });\r\n    }\r\n});\r\n// ----- (LEO DONE) --------------------------------------------------------------------------------\r\n\r\n// ----- (MUNA) ------------------------------------------------------------------------------------\r\n<<<<<<< Updated upstream\r\n=======\r\napp.get('/api/member/profile', authenticateUser, async (req, res) => {\r\n    const memberId = req.userId;  // `authenticateUser` middleware attaches userId to req\r\n    try {\r\n        const [result] = await db.query('SELECT first_name, last_name FROM users WHERE user_id = ?', [memberId]);\r\n        if (result.length > 0) {\r\n            const member = result[0];\r\n            res.json({firstName: member.first_name, lastName: member.last_name});\r\n        } else {\r\n            res.status(404).json({error: 'Member not found'});\r\n        }\r\n    } catch (error) {\r\n        res.status(500).json({error: 'Database error'});\r\n    }\r\n});\r\n>>>>>>> Stashed changes\r\n\r\n// (Assuming MUNA's endpoints are already correctly implemented)\r\n// ----- (MUNA DONE) ------------------------------------------------------------------------------\r\n\r\n// ----- (TYLER) ----------------------------------------------------------------------------------\r\n\r\n// Add a new event\r\napp.post('/api/events', async (req, res) => {\r\n    const {name, description, location, status} = req.body;\r\n    try {\r\n        const [result] = await db.query('INSERT INTO event_ (name_, description_, location, status) VALUES (?, ?, ?, ?)', [name, description, location, status])\r\n        res.json({id: result.insertId, message: 'Event added successfully.'});\r\n    } catch (error) {\r\n        console.error('Error adding event:', error);\r\n        res.status(500).json({message: 'Server error adding event.'});\r\n    }\r\n});\r\n\r\n// Update event information\r\napp.put('/api/events/:id', async (req, res) => {\r\n    const {id} = req.params;\r\n    const {name, description, location, status} = req.body;\r\n\r\n    const allowedStatuses = ['upcoming', 'ongoing', 'completed'];\r\n    if (!allowedStatuses.includes(status)) {\r\n        return res.status(400).json({message: 'Invalid status value.'});\r\n    }\r\n\r\n    try {\r\n        const [result] = await db.query('UPDATE event_ SET name_ = ?, description_ = ?, location = ?, status = ? WHERE event_id = ?', [name, description, location, status, id]);\r\n\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Event not found.'});\r\n        }\r\n        res.json({message: 'Event updated successfully.'});\r\n    } catch (error) {\r\n        console.error('Error updating event:', error);\r\n        res.status(500).json({message: 'Server error updating event.'});\r\n    }\r\n})\r\n\r\n// Soft delete an event\r\napp.delete('/api/events/:id', async (req, res) => {\r\n    const eventId = req.params.id;\r\n    try {\r\n        const [result] = await db.query('UPDATE event_ SET is_deleted = TRUE WHERE event_id = ?', [eventId]);\r\n        if (result.affectedRows === 0) {\r\n            return res.status(404).json({message: 'Event not found.'});\r\n        }\r\n        res.json({message: 'Event deleted successfully.'});\r\n    } catch (error) {\r\n        console.error('Error deleting event:', error);\r\n        res.status(500).json({message: 'Server error deleting event.'});\r\n    }\r\n})\r\n\r\n// Fetch all non-deleted events from the database\r\napp.get('/api/events', async (req, res) => {\r\n    try {\r\n        const [result] = await db.query('SELECT * FROM event_ WHERE is_deleted = FALSE');\r\n        res.json(result);\r\n    } catch (error) {\r\n        console.error('Error fetching events:', error);\r\n        res.status(500).json({message: 'Server error fetching events.'});\r\n    }\r\n})\r\n\r\n// Fetch the total number of members that signed up for an event\r\napp.get('/api/events/:id/members', async (req, res) => {\r\n    const eventId = req.params.id;\r\n    try {\r\n        const [result] = await db.query(`SELECT DISTINCT membership.fname, membership.lname \r\n                                        FROM events_transaction \r\n                                        JOIN membership ON events_transaction.membership_id = membership.membership_id\r\n                                        WHERE event_id = ?`, [eventId]);\r\n        res.json(result);\r\n    } catch (error) {\r\n        console.error('Error fetching members:', error);\r\n        res.status(500).json({message: 'Server error fetching members.'});\r\n    }\r\n});\r\n\r\n// Fetch report data for a specific event\r\napp.get('/api/events/:id/report', async (req, res) => {\r\n    const { id } = req.params;\r\n    try {\r\n        const [result] = await db.query('SELECT eventName, totalMembersSignedUp, totalRevenue FROM EventReport WHERE eventID = ?',\r\n            [id]);\r\n        if (result.length === 0) {\r\n            return res.status(404).json({ message: 'Report not found for the specified event.' });\r\n        }\r\n        res.json(result[0]);\r\n    }\r\n    catch (error){\r\n        console.error('Error fetching event report:', error);\r\n        res.status(500).json({ message: 'Server error fetching event report.' });\r\n    }\r\n})\r\n\r\n// ----- (TYLER DONE) ---------------------------------------------------------------------------------\r\n\r\n// ----- (DENNIS) ---------------------------------------------------------------------------------\r\n\r\n\r\n// Membership registration endpoint\r\napp.post('/membership-registration', async (req, res) => {\r\n    console.log('Received membership registration request:', req.body);\r\n\r\n    const {\r\n        first_name,\r\n        last_name,\r\n        username,\r\n        type_of_membership\r\n    } = req.body;\r\n\r\n    try {\r\n        // Start transaction\r\n        await db.query('START TRANSACTION');\r\n\r\n        // Check if user exists and get their role_id\r\n        const [existingUser] = await db.query(\r\n            'SELECT user_id, role_id FROM users WHERE username = ?',\r\n            [username]\r\n        );\r\n\r\n        console.log('Existing user data:', existingUser);\r\n\r\n        if (existingUser.length === 0) {\r\n            await db.query('ROLLBACK');\r\n            console.log('User not found:', username);\r\n            return res.status(404).json({ error: 'User not found. Please register as a user first.' });\r\n        }\r\n\r\n        const user = existingUser[0];\r\n        console.log('User role_id:', user.role_id);\r\n\r\n        // Check if user already has a membership\r\n        const [existingMembership] = await db.query(\r\n            'SELECT * FROM membership WHERE user_id = ?',\r\n            [user.user_id]\r\n        );\r\n\r\n        console.log('Existing membership:', existingMembership);\r\n\r\n        if (existingMembership.length > 0) {\r\n            await db.query('ROLLBACK');\r\n            console.log('User already has membership');\r\n            return res.status(400).json({ error: 'User already has a membership' });\r\n        }\r\n\r\n        if (user.role_id !== 3) {\r\n            await db.query('ROLLBACK');\r\n            console.log('Invalid role_id:', user.role_id);\r\n            return res.status(403).json({\r\n                error: user.role_id === 4\r\n                    ? 'User already has an active membership'\r\n                    : 'User must have role_id 3 to register for membership'\r\n            });\r\n        }\r\n\r\n        // Calculate expiration date (1 month from now)\r\n        const expirationDate = new Date();\r\n        expirationDate.setMonth(expirationDate.getMonth() + 1);\r\n\r\n        // Create membership record with correct column names (fname and lname)\r\n        const membershipResult = await db.query(\r\n            `INSERT INTO membership \r\n            (user_id, type_of_membership, expire_date, expiration_warning, fname, lname)\r\n            VALUES (?, ?, ?, ?, ?, ?)`,\r\n            [user.user_id, type_of_membership.toLowerCase(), expirationDate, 0, first_name, last_name]\r\n        );\r\n\r\n        console.log('Membership creation result:', membershipResult);\r\n\r\n        // Update user's role_id to 4\r\n        const userUpdateResult = await db.query(\r\n            'UPDATE users SET role_id = 4 WHERE user_id = ?',\r\n            [user.user_id]\r\n        );\r\n\r\n        console.log('User role update result:', userUpdateResult);\r\n\r\n        // Commit transaction\r\n        await db.query('COMMIT');\r\n        console.log('Transaction committed successfully');\r\n        res.status(201).json({ message: 'Membership registration successful' });\r\n\r\n    } catch (error) {\r\n        // Rollback transaction on error\r\n        await db.query('ROLLBACK');\r\n        console.error('Error in membership registration:', error);\r\n        res.status(500).json({ error: 'Internal server error during membership registration: ' + error.message });\r\n    }\r\n});\r\n\r\n// Altered Leo's login backend to accomodate for membership expiration alert trigger\r\n\r\n\r\n\r\n// (Assuming DENNIS's endpoints are already correctly implemented)\r\n// ----- (DENNIS DONE) ----------------------------------------------------------------------------\r\n\r\n// Start the server\r\napp.listen(port, () => {\r\n    console.log(`Server Running on http://localhost:${port}`);\r\n});\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/frontend/src/server.js b/frontend/src/server.js
--- a/frontend/src/server.js	(revision 13a78189c8e40ebcb2fc4e34d15700aca0e7aa8d)
+++ b/frontend/src/server.js	(date 1731863900000)
@@ -215,11 +215,11 @@
 app.use('/assets/artists', express.static(path.join(__dirname, 'assets/artists')));
 const artistStorage = multer.diskStorage({
     destination: (req, file, cb) => {
-      cb(null, path.join(__dirname, 'assets/artists')); // Save to frontend/src/assets/artists
+        cb(null, path.join(__dirname, 'assets/artists')); // Save to frontend/src/assets/artists
     },
     filename: (req, file, cb) => {
-      const safeFileName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
-      cb(null, safeFileName);
+        const safeFileName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
+        cb(null, safeFileName);
     }
 });
 const uploadArtistImage = multer({ storage: artistStorage });
@@ -285,7 +285,7 @@
     }
 
     try {
-        const [user] = await db.query(`
+        const [userRows] = await db.query(`
             SELECT users.*, roles.role_name
             FROM users
             WHERE username = ?
@@ -944,25 +944,25 @@
             WHERE YEAR (t.transaction_date) = ?
         `;
         params = [selectedYear];
-        } else if (reportPeriodType === 'single_day') {
-            query = `
-                SELECT t.transaction_id,
-                       t.transaction_date,
-                       t.transaction_type,
-                       t.payment_status,
-                       u.username,
-                       tgi.item_id,
-                       gsi.name_                              as item_name,
-                       tgi.quantity,
-                       tgi.price_at_purchase,
-                       (tgi.quantity * tgi.price_at_purchase) as item_total
-                FROM \`transaction\` t
-                         JOIN transaction_giftshopitem tgi ON t.transaction_id = tgi.transaction_id
-                         JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id
-                         JOIN users u ON t.user_id = u.user_id
-                WHERE DATE (t.transaction_date) = ?
-            `;
-            params = [selectedDate];
+    } else if (reportPeriodType === 'single_day') {
+        query = `
+            SELECT t.transaction_id,
+                   t.transaction_date,
+                   t.transaction_type,
+                   t.payment_status,
+                   u.username,
+                   tgi.item_id,
+                   gsi.name_                              as item_name,
+                   tgi.quantity,
+                   tgi.price_at_purchase,
+                   (tgi.quantity * tgi.price_at_purchase) as item_total
+            FROM \`transaction\` t
+                     JOIN transaction_giftshopitem tgi ON t.transaction_id = tgi.transaction_id
+                     JOIN giftshopitem gsi ON tgi.item_id = gsi.item_id
+                     JOIN users u ON t.user_id = u.user_id
+            WHERE DATE (t.transaction_date) = ?
+        `;
+        params = [selectedDate];
     } else {
         throw new Error('Invalid report period type for transaction details report.');
     }
@@ -1310,7 +1310,7 @@
         }
         await connection.query(
             `INSERT INTO bought_tickets (ticket_type_id, user_id, transaction_id, visit_date, price_at_purchase)
-       VALUES ?`,
+             VALUES ?`,
             [boughtTicketsValues]
         );
 
@@ -1373,8 +1373,8 @@
 
 // ----- (MUNA) ------------------------------------------------------------------------------------
 <<<<<<< Updated upstream
-=======
-app.get('/api/member/profile', authenticateUser, async (req, res) => {
+                    =======
+                app.get('/api/member/profile', authenticateUser, async (req, res) => {
     const memberId = req.userId;  // `authenticateUser` middleware attaches userId to req
     try {
         const [result] = await db.query('SELECT first_name, last_name FROM users WHERE user_id = ?', [memberId]);
@@ -1460,10 +1460,10 @@
 app.get('/api/events/:id/members', async (req, res) => {
     const eventId = req.params.id;
     try {
-        const [result] = await db.query(`SELECT DISTINCT membership.fname, membership.lname 
-                                        FROM events_transaction 
-                                        JOIN membership ON events_transaction.membership_id = membership.membership_id
-                                        WHERE event_id = ?`, [eventId]);
+        const [result] = await db.query(`SELECT DISTINCT membership.fname, membership.lname
+                                         FROM events_transaction
+                                                  JOIN membership ON events_transaction.membership_id = membership.membership_id
+                                         WHERE event_id = ?`, [eventId]);
         res.json(result);
     } catch (error) {
         console.error('Error fetching members:', error);
@@ -1555,9 +1555,9 @@
 
         // Create membership record with correct column names (fname and lname)
         const membershipResult = await db.query(
-            `INSERT INTO membership 
-            (user_id, type_of_membership, expire_date, expiration_warning, fname, lname)
-            VALUES (?, ?, ?, ?, ?, ?)`,
+            `INSERT INTO membership
+             (user_id, type_of_membership, expire_date, expiration_warning, fname, lname)
+             VALUES (?, ?, ?, ?, ?, ?)`,
             [user.user_id, type_of_membership.toLowerCase(), expirationDate, 0, first_name, last_name]
         );
 
@@ -1595,4 +1595,3 @@
 app.listen(port, () => {
     console.log(`Server Running on http://localhost:${port}`);
 });
-
